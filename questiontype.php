<?php

// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
///////////////////
/// pycode ///
///////////////////
/// PYCODE QUESTION TYPE CLASS //////////////////
// A pycode question consists of a specification for a simple
// python function (which mustn't do any I/O or system calls).
// The student's response must be Python source code that defines
// the specified function. The student's code is executed by
// a set of test cases, all of which must pass for the question
// to be marked correct. The code execution takes place in an
// external sandboxed Python interpreter (e.g. using pypy,
// see http://codespeak.net/pypy/dist/pypy/doc/sandbox.html).
// There are no part marks -- the question is marked 100% or
// zero. It is expected that each pycode question will have its
// own submit button and students will keep submitting until
// they pass all tests, so that their mark will be based on
// the number of submissions and the penalty per wrong
// submissions.

/**
 * @package 	qtype
 * @subpackage 	pycode
 * @copyright 	&copy; 2011 Richard Lobb
 * @author 	Richard Lobb richard.lobb@canterbury.ac.nz
 */

// require_once($CFG->dirroot . '/question/type/pycode/question.php');

/**
 * qtype_pcode extends the base question_type to pycode-specific functionality.
 * A pycode question requires an additional DB table, question_pycode_testcases,
 * that contains the definitions for the testcases associated with a pycode
 * question. There are an arbitrary number of these, so they can't be handled
 * by adding columns to the pycode_question table.
 */
class qtype_pycode extends question_type {

    public function name() {
        return 'pycode';
    }
    
    /**
     * Whether this question type can perform a frequency analysis of student
     * responses.
     *
     * If this method returns true, you must implement the get_possible_responses
     * method, and the question_definition class must implement the
     * classify_response method.
     *
     * @return bool whether this report can analyse all the student reponses
     * for things like the quiz statistics report.
     */
    public function can_analyse_responses() {
        return FALSE;  // TODO Consider if this functionality should be enabled
    }
    
    
    /**
     * Abstract function implemented by each question type. It runs all the code
     * required to set up and save a question of any type for testing purposes.
     * Alternate DB table prefix may be used to facilitate data deletion.
     */
    public function generate_test($name, $courseid=null) {
        // Closer inspection shows that this method isn't actually implemented
        // by even the standard question types and wouldn't be called for any
        // non-standard ones even if implemented. I'm leaving the code in, in
        // case it's ever needed, but have added an exception-throwing line
        // to draw attention to the fact it's not well thought through.
        throw new coding_exception('Unexpected call to generate_test. Read code for details.');
        list($form, $question) = parent::generate_test($name, $courseid);
        $form->questiontext = 'Pycode test question, generated by script: ' .
                ' write a question sqr(n) that returns n squared';

        $testcase = new stdClass;
        $testcase->questionid = 0;
        $testcase->shellinput = 'sqrt(-11)';
        $testcase->output = '121';
        $testcase->useasexample = 1;
        $testcase->hidden = 0;

        $form->testcases = array($testcase);
        return array($form, $question);
    }
    
    
    // Function to copy testcases from form fields into question->testcases
    private function copy_testcases_from_form(&$question) {
        $testcases = array();
        $numTests = count($question->shellinput);
        assert(count($question->output) == $numTests);
        for($i = 0; $i < $numTests; $i++) {
            $input = filterCrs($question->shellinput[$i]);
            $stdin = filterCrs($question->stdin[$i]);
            $output = filterCrs($question->output[$i]);
            if ($input == '' && $stdin == '' && $output == '') {
                continue;
            }
            $testcase = new stdClass;
            $testcase->questionid = isset($question->id) ? $question->id : 0;
            $testcase->shellinput = $input;
            $testcase->stdin = $stdin;
            $testcase->output = $output;
            $testcase->useasexample = isset($question->useasexample[$i]);
            $testcase->hidden = isset($question->hidden[$i]);
            $testcases[] = $testcase;
        }

        $question->testcases = $testcases;
    }

    // This override saves the set of testcases to the database
    // Note that the parameter isn't a question object, but the question form
    // (or a mock-up of it). See questiontypebase.php. 
    // Can't use the default get/save_question_options methods as there
    // are arbitrarily many testcases.

    public function save_question_options($question) {
        global $DB;

        if (!isset($question->testcases)) {
            $this->copy_testcases_from_form($question);
        }

        if (!$oldtestcases = $DB->get_records('question_pycode_testcases', array('questionid' => $question->id), 'id ASC')) {
            $oldtestcases = array();
        }


        foreach ($question->testcases as $tc) {
            if (($oldtestcase = array_shift($oldtestcases))) { // Existing testcase, so reuse it
                $tc->id = $oldtestcase->id;
                $DB->update_record("question_pycode_testcases", $tc);
            } else {
                // A new testcase
                $tc->questionid = $question->id;
                $testcase->id = $DB->insert_record("question_pycode_testcases", $tc);
            }
        }


        // delete old testcase records
        foreach ($oldtestcases as $otc) {
            $DB->delete_records('question_pycode_testcases', array('id' => $otc->id));
        }

        return true;
    }

    // Load the question options (namely testcases) from the database
    // into the 'question' (which is actually a pycode question edit form).
    public function get_question_options(&$question) {
        global $CFG, $DB, $OUTPUT;

        if (!$question->testcases = $DB->get_records_sql("
                    SELECT * 
                    FROM {question_pycode_testcases}
                    WHERE questionid = ?", array($question->id))) {

            echo $OUTPUT->notification("Failed to load testcases from the table question_pycode_testcases for question id {$question->id}");
            return false;
        }

        return true;
    }
    
    
    // The 'questiondata' here is actually (something like) a pycode question
    // edit form, and we need to extend the baseclass method to copy the
    // testcases across to the under-creation question definition.
    protected function initialise_question_instance(question_definition $question, $questiondata) {
        parent::initialise_question_instance($question, $questiondata);
        $question->testcases = $questiondata->testcases;
    }

    
    // Delete the testcases when this question is deleted.
    public function delete_question($questionid, $contextid) {
        global $DB;
        $success = $DB->delete_records('question_pycode_testcases', array('questionid' => $questionid));
        return $success && parent::delete_question($questionid, $contextid);
    }


    // TODO Override the default submit button so can hook in javascript to prevent
    // multiple clicking while a submission is being marked.
//    function print_question_submit_buttons(&$question, &$state, $cmoptions, $options) {
//        if (($cmoptions->optionflags & QUESTION_ADAPTIVE) and !$options->readonly) {
//            echo '<input type="submit" name="', $question->name_prefix, 'submit" value="',
//            get_string('mark', 'quiz'), '" class="submit btn" onclick="submitClicked(event)" />';
//        }
//    }


/// IMPORT/EXPORT FUNCTIONS /////////////////

    /*
     * Imports question from the Moodle XML format
     *
     * Overrides default since pycode questions contain a list of testcases,
     * not a list of answers.
     */
    function import_from_xml($data, $question, $format, $extra=null) {
        $question_type = $data['@']['type'];
        if ($question_type != $this->name()) {
            return false;
        }

        $qo = $format->import_headers($data);  // All the basic stuff
        $qo->qtype = $question_type;

        $testcases = $data['#']['testcases'][0]['#']['testcase'];

        $qo->testcases = array();

        foreach ($testcases as $testcase) {
            $tc = new stdClass;
            $tc->shellinput = trim($testcase['#']['shellinput'][0]['#']['text'][0]['#']);
            $tc->stdin = $testcase['#']['stdin'] == "1" ? 1 : 0;
            $tc->output = trim($testcase['#']['output'][0]['#']['text'][0]['#']);
            $tc->hidden = $testcase['@']['hidden'] == "1" ? 1 : 0;
            $tc->useasexample = $testcase['@']['useasexample'] == "1" ? 1 : 0;
            $qo->testcases[] = $tc;
        }
        return $qo;
    }

    /*
     * Export question to the Moodle XML format
     *
     * We override the default method because we don't have 'answers' but
     * testcases.
     */

    function export_to_xml($question, $format, $extra=null) {
        if ($extra !== null) {
            return false;
        }

        $expout = "    <testcases>\n";
        foreach ($question->testcases as $testcase) {
            $useasexample = $testcase->useasexample ? 1 : 0;
            $hidden = $testcase->hidden ? 1 : 0;
            $expout .= "      <testcase useasexample=\"$useasexample\" hidden=\"$hidden\">\n";
            $expout .= "        <shellinput>\n";
            $expout .= $format->writetext($testcase->shellinput, 4, false);
            $expout .= "        </shellinput>\n";
            $expout .= "        <stdin>\n";
            $expout .= $format->writetext($testcase->stdin, 4, false);
            $expout .= "        </stdin>\n";            
            $expout .= "        <output>\n";
            $expout .= $format->writetext($testcase->output, 4, false);
            $expout .= "        </output>\n";
            $expout .= "    </testcase>\n";
        }
        $expout .= "    </testcases>\n";
        return $expout;
    }
}

// === Utility funcs

/** Remove all '\r' chars from $s and also trim trailing newlines */
function filterCrs($s) {
    $s = str_replace("\r", "", $s);
    while (substr($s, strlen($s) - 1, 1) == '\n') {
        $s = substr($s, 0, strlen($s) - 1);
    }
    return $s;
}